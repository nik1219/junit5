/*
 * Copyright 2015-2021 the original author or authors.
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License v2.0 which
 * accompanies this distribution and is available at
 *
 * https://www.eclipse.org/legal/epl-v20.html
 */

package org.junit.platform.reporting.open.xml;

import static org.opentest4j.reporting.events.core.CoreFactory.attachments;
import static org.opentest4j.reporting.events.core.CoreFactory.cpuCores;
import static org.opentest4j.reporting.events.core.CoreFactory.data;
import static org.opentest4j.reporting.events.core.CoreFactory.directorySource;
import static org.opentest4j.reporting.events.core.CoreFactory.fileSource;
import static org.opentest4j.reporting.events.core.CoreFactory.hostName;
import static org.opentest4j.reporting.events.core.CoreFactory.infrastructure;
import static org.opentest4j.reporting.events.core.CoreFactory.metadata;
import static org.opentest4j.reporting.events.core.CoreFactory.operatingSystem;
import static org.opentest4j.reporting.events.core.CoreFactory.reason;
import static org.opentest4j.reporting.events.core.CoreFactory.result;
import static org.opentest4j.reporting.events.core.CoreFactory.sources;
import static org.opentest4j.reporting.events.core.CoreFactory.tag;
import static org.opentest4j.reporting.events.core.CoreFactory.tags;
import static org.opentest4j.reporting.events.core.CoreFactory.uriSource;
import static org.opentest4j.reporting.events.core.CoreFactory.userName;
import static org.opentest4j.reporting.events.java.JavaFactory.classSource;
import static org.opentest4j.reporting.events.java.JavaFactory.classpathResourceSource;
import static org.opentest4j.reporting.events.java.JavaFactory.fileEncoding;
import static org.opentest4j.reporting.events.java.JavaFactory.heapSize;
import static org.opentest4j.reporting.events.java.JavaFactory.javaVersion;
import static org.opentest4j.reporting.events.java.JavaFactory.methodSource;
import static org.opentest4j.reporting.events.java.JavaFactory.packageSource;
import static org.opentest4j.reporting.events.java.JavaFactory.throwable;
import static org.opentest4j.reporting.events.root.RootFactory.finished;
import static org.opentest4j.reporting.events.root.RootFactory.reported;
import static org.opentest4j.reporting.events.root.RootFactory.started;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.file.Path;
import java.time.Instant;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.platform.commons.JUnitException;
import org.junit.platform.commons.util.StringUtils;
import org.junit.platform.engine.ConfigurationParameters;
import org.junit.platform.engine.TestExecutionResult;
import org.junit.platform.engine.TestSource;
import org.junit.platform.engine.UniqueId;
import org.junit.platform.engine.reporting.ReportEntry;
import org.junit.platform.engine.support.descriptor.ClassSource;
import org.junit.platform.engine.support.descriptor.ClasspathResourceSource;
import org.junit.platform.engine.support.descriptor.CompositeTestSource;
import org.junit.platform.engine.support.descriptor.DirectorySource;
import org.junit.platform.engine.support.descriptor.FileSource;
import org.junit.platform.engine.support.descriptor.MethodSource;
import org.junit.platform.engine.support.descriptor.PackageSource;
import org.junit.platform.engine.support.descriptor.UriSource;
import org.junit.platform.launcher.TestExecutionListener;
import org.junit.platform.launcher.TestIdentifier;
import org.junit.platform.launcher.TestPlan;
import org.junit.platform.launcher.listeners.OutputDir;
import org.opentest4j.reporting.events.api.DocumentWriter;
import org.opentest4j.reporting.events.api.NamespaceRegistry;
import org.opentest4j.reporting.events.core.CoreFactory;
import org.opentest4j.reporting.events.core.Result;
import org.opentest4j.reporting.events.core.Sources;
import org.opentest4j.reporting.events.java.JavaFactory;
import org.opentest4j.reporting.events.root.Events;
import org.opentest4j.reporting.events.root.RootFactory;

public class OpenTestReportGeneratingListener implements TestExecutionListener {

	private static final String ENABLED_PROPERTY_NAME = "junit.platform.reporting.open.xml.enabled";

	private static final NamespaceRegistry NAMESPACE_REGISTRY = NamespaceRegistry.builder(CoreFactory.NAMESPACE) //
			.add("e", RootFactory.NAMESPACE) //
			.add("java", JavaFactory.NAMESPACE) //
			.add("junit", JUnitFactory.NAMESPACE, "https://junit.org/junit5/schemas/open-test-reporting/junit-1.9.xsd") //
			.build();

	private final AtomicInteger idCounter = new AtomicInteger();
	private final Map<UniqueId, String> inProgressIds = new ConcurrentHashMap<>();
	private DocumentWriter<Events> eventsFileWriter = DocumentWriter.noop();

	public OpenTestReportGeneratingListener() {
	}

	@Override
	public void testPlanExecutionStarted(TestPlan testPlan) {
		ConfigurationParameters config = testPlan.getConfigurationParameters();
		if (isEnabled(config)) {
			Path eventsXml = OutputDir.create(config.get("junit.platform.reporting.output.dir")) //
					.createFile("junit-platform-events", "xml");
			try {
				eventsFileWriter = Events.createDocumentWriter(NAMESPACE_REGISTRY, eventsXml);
				reportInfrastructure();
			}
			catch (Exception e) {
				throw new RuntimeException("Failed to initialize XML events file: " + eventsXml, e);
			}
		}
	}

	private Boolean isEnabled(ConfigurationParameters config) {
		return config.getBoolean(ENABLED_PROPERTY_NAME).orElse(false);
	}

	private void reportInfrastructure() {
		eventsFileWriter.append(infrastructure(), infrastructure -> {
			try {
				String hostName = InetAddress.getLocalHost().getHostName();
				infrastructure.addChild(hostName(hostName));
			}
			catch (UnknownHostException ignored) {
			}
			infrastructure.addChild(userName(System.getProperty("user.name")));
			infrastructure.addChild(operatingSystem(System.getProperty("os.name")));
			infrastructure.addChild(cpuCores(Runtime.getRuntime().availableProcessors()));
			infrastructure.addChild(javaVersion(System.getProperty("java.version")));
			infrastructure.addChild(fileEncoding(System.getProperty("file.encoding")));
			infrastructure.addChild(heapSize(), heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));
		});
	}

	@Override
	public void testPlanExecutionFinished(TestPlan testPlan) {
		try {
			eventsFileWriter.close();
		}
		catch (IOException e) {
			throw new UncheckedIOException("Failed to close XML events file", e);
		}
		finally {
			eventsFileWriter = DocumentWriter.noop();
		}
	}

	@Override
	public void executionSkipped(TestIdentifier testIdentifier, String reason) {
		String id = String.valueOf(idCounter.incrementAndGet());
		reportStarted(testIdentifier, id);
		eventsFileWriter.append(finished(id, Instant.now()), //
			finished -> finished.addChild(result(Result.Status.SKIPPED), result -> {
				if (StringUtils.isNotBlank(reason)) {
					result.addChild(reason(reason));
				}
			}));
	}

	@Override
	public void executionStarted(TestIdentifier testIdentifier) {
		String id = String.valueOf(idCounter.incrementAndGet());
		inProgressIds.put(testIdentifier.getUniqueIdObject(), id);
		reportStarted(testIdentifier, id);
	}

	private void reportStarted(TestIdentifier testIdentifier, String id) {
		eventsFileWriter.append(started(id, Instant.now(), testIdentifier.getDisplayName()), started -> {
			testIdentifier.getParentIdObject().ifPresent(parentId -> started.withParentId(inProgressIds.get(parentId)));
			started.addChild(metadata(), metadata -> {
				if (!testIdentifier.getTags().isEmpty()) {
					metadata.addChild(tags(), tags -> //
					testIdentifier.getTags().forEach(tag -> tags.addChild(tag(tag.getName()))));
				}
				metadata.addChild(JUnitFactory.uniqueId(testIdentifier.getUniqueIdObject()));
				metadata.addChild(JUnitFactory.legacyReportingName(testIdentifier.getLegacyReportingName()));
				metadata.addChild(JUnitFactory.type(testIdentifier.getType()));
			});
			testIdentifier.getSource().ifPresent(
				source -> started.addChild(sources(), sources -> addTestSource(source, sources)));
		});
	}

	private void addTestSource(TestSource source, Sources sources) {
		if (source instanceof CompositeTestSource) {
			((CompositeTestSource) source).getSources().forEach(it -> addTestSource(it, sources));
		}
		else if (source instanceof ClassSource) {
			ClassSource classSource = (ClassSource) source;
			sources.addChild(classSource(classSource.getClassName()), //
				element -> classSource.getPosition().ifPresent(
					filePosition -> element.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
		}
		else if (source instanceof MethodSource) {
			MethodSource methodSource = (MethodSource) source;
			sources.addChild(methodSource(methodSource.getClassName(), methodSource.getMethodName()), element -> {
				String methodParameterTypes = methodSource.getMethodParameterTypes();
				if (methodParameterTypes != null) {
					element.withMethodParameterTypes(methodParameterTypes);
				}
			});
		}
		else if (source instanceof ClasspathResourceSource) {
			ClasspathResourceSource classpathResourceSource = (ClasspathResourceSource) source;
			sources.addChild(classpathResourceSource(classpathResourceSource.getClasspathResourceName()), //
				element -> classpathResourceSource.getPosition().ifPresent(
					filePosition -> element.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
		}
		else if (source instanceof PackageSource) {
			sources.addChild(packageSource(((PackageSource) source).getPackageName()));
		}
		else if (source instanceof FileSource) {
			FileSource fileSource = (FileSource) source;
			sources.addChild(fileSource(fileSource.getFile()), //
				element -> fileSource.getPosition().ifPresent(
					filePosition -> element.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
		}
		else if (source instanceof DirectorySource) {
			sources.addChild(directorySource(((DirectorySource) source).getFile()));
		}
		else if (source instanceof UriSource) {
			sources.addChild(uriSource(((UriSource) source).getUri()));
		}
	}

	@Override
	public void reportingEntryPublished(TestIdentifier testIdentifier, ReportEntry entry) {
		String id = inProgressIds.get(testIdentifier.getUniqueIdObject());
		eventsFileWriter.append(reported(id, Instant.now()), //
			reported -> reported.addChild(attachments(), attachments -> attachments.addChild(data(), data -> {
				data.withTime(entry.getTimestamp());
				entry.getKeyValuePairs().forEach(data::addEntry);
			})));
	}

	@Override
	public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {
		String id = inProgressIds.remove(testIdentifier.getUniqueIdObject());
		eventsFileWriter.append(finished(id, Instant.now()), //
			finished -> finished.addChild(result(convertStatus(testExecutionResult.getStatus())), //
				result -> testExecutionResult.getThrowable() //
						.ifPresent(throwable -> result.addChild(throwable(throwable)))));
	}

	private Result.Status convertStatus(TestExecutionResult.Status status) {
		switch (status) {
			case FAILED:
				return Result.Status.FAILED;
			case SUCCESSFUL:
				return Result.Status.SUCCESSFUL;
			case ABORTED:
				return Result.Status.ABORTED;
		}
		throw new JUnitException("Unhandled status: " + status);
	}

}
