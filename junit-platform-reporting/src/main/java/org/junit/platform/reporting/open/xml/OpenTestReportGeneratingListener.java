/*
 * Copyright 2015-2021 the original author or authors.
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License v2.0 which
 * accompanies this distribution and is available at
 *
 * https://www.eclipse.org/legal/epl-v20.html
 */

package org.junit.platform.reporting.open.xml;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.file.Path;
import java.time.Instant;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.platform.commons.JUnitException;
import org.junit.platform.commons.util.StringUtils;
import org.junit.platform.engine.ConfigurationParameters;
import org.junit.platform.engine.TestExecutionResult;
import org.junit.platform.engine.TestSource;
import org.junit.platform.engine.UniqueId;
import org.junit.platform.engine.reporting.ReportEntry;
import org.junit.platform.engine.support.descriptor.ClassSource;
import org.junit.platform.engine.support.descriptor.ClasspathResourceSource;
import org.junit.platform.engine.support.descriptor.CompositeTestSource;
import org.junit.platform.engine.support.descriptor.DirectorySource;
import org.junit.platform.engine.support.descriptor.FileSource;
import org.junit.platform.engine.support.descriptor.MethodSource;
import org.junit.platform.engine.support.descriptor.PackageSource;
import org.junit.platform.engine.support.descriptor.UriSource;
import org.junit.platform.launcher.TestExecutionListener;
import org.junit.platform.launcher.TestIdentifier;
import org.junit.platform.launcher.TestPlan;
import org.junit.platform.launcher.listeners.OutputDir;
import org.opentest4j.reporting.events.api.DocumentWriter;
import org.opentest4j.reporting.events.api.NamespaceRegistry;
import org.opentest4j.reporting.events.core.CoreFactory;
import org.opentest4j.reporting.events.core.Result;
import org.opentest4j.reporting.events.core.Sources;
import org.opentest4j.reporting.events.java.JavaFactory;
import org.opentest4j.reporting.events.node.EventFactory;
import org.opentest4j.reporting.events.node.Events;

public class OpenTestReportGeneratingListener implements TestExecutionListener {

	private static final String ENABLED_PROPERTY_NAME = "junit.platform.reporting.open.xml.enabled";

	private static final NamespaceRegistry NAMESPACE_REGISTRY = NamespaceRegistry.builder() //
			.add(EventFactory.NAMESPACE, "e") //
			.add(JavaFactory.NAMESPACE, "java") //
			.add(JUnitFactory.NAMESPACE, "junit") //
			.build();

	private final AtomicInteger idCounter = new AtomicInteger();
	private final Map<UniqueId, String> inProgressIds = new ConcurrentHashMap<>();
	private DocumentWriter<Events> eventsFileWriter = DocumentWriter.noop();

	public OpenTestReportGeneratingListener() {
	}

	@Override
	public void testPlanExecutionStarted(TestPlan testPlan) {
		ConfigurationParameters config = testPlan.getConfigurationParameters();
		if (isEnabled(config)) {
			Path eventsXml = OutputDir.create(config.get("junit.platform.reporting.output.dir")) //
					.createFile("junit-platform-events", "xml");
			try {
				eventsFileWriter = Events.createDocumentWriter(NAMESPACE_REGISTRY, CoreFactory.NAMESPACE, eventsXml);
				reportInfrastructure();
			}
			catch (Exception e) {
				throw new RuntimeException("Failed to initialize XML events file: " + eventsXml, e);
			}
		}
	}

	private Boolean isEnabled(ConfigurationParameters config) {
		return config.getBoolean(ENABLED_PROPERTY_NAME).orElse(false);
	}

	private void reportInfrastructure() {
		eventsFileWriter.append(EventFactory.infrastructure(), infrastructure -> {
			try {
				String hostName = InetAddress.getLocalHost().getHostName();
				infrastructure.addChild(CoreFactory.hostName(hostName));
			}
			catch (UnknownHostException ignored) {
			}
			infrastructure.addChild(CoreFactory.userName(System.getProperty("user.name")));
			infrastructure.addChild(CoreFactory.operatingSystem(System.getProperty("os.name")));
			infrastructure.addChild(CoreFactory.cpuCores(Runtime.getRuntime().availableProcessors()));
			infrastructure.addChild(JavaFactory.javaVersion(System.getProperty("java.version")));
			infrastructure.addChild(JavaFactory.fileEncoding(System.getProperty("file.encoding")));
			infrastructure.addChild(JavaFactory.heapSize(),
				heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));
		});
	}

	@Override
	public void testPlanExecutionFinished(TestPlan testPlan) {
		try {
			eventsFileWriter.close();
		}
		catch (IOException e) {
			throw new UncheckedIOException("Failed to close XML events file", e);
		}
		finally {
			eventsFileWriter = DocumentWriter.noop();
		}
	}

	@Override
	public void executionSkipped(TestIdentifier testIdentifier, String reason) {
		String id = String.valueOf(idCounter.incrementAndGet());
		reportStarted(testIdentifier, id);
		eventsFileWriter.append(EventFactory.finished(id, Instant.now()), //
			finished -> finished.addChild(CoreFactory.result(Result.Status.SKIPPED), result -> {
				if (StringUtils.isNotBlank(reason)) {
					result.addChild(CoreFactory.reason(reason));
				}
			}));
	}

	@Override
	public void executionStarted(TestIdentifier testIdentifier) {
		String id = String.valueOf(idCounter.incrementAndGet());
		inProgressIds.put(testIdentifier.getUniqueIdObject(), id);
		reportStarted(testIdentifier, id);
	}

	private void reportStarted(TestIdentifier testIdentifier, String id) {
		eventsFileWriter.append(EventFactory.started(id, Instant.now(), testIdentifier.getDisplayName()), started -> {
			testIdentifier.getParentIdObject().ifPresent(parentId -> started.withParentId(inProgressIds.get(parentId)));
			started.addChild(CoreFactory.metadata(), metadata -> {
				if (!testIdentifier.getTags().isEmpty()) {
					metadata.addChild(CoreFactory.tags(), tags -> //
					testIdentifier.getTags().forEach(tag -> tags.addChild(CoreFactory.tag(tag.getName()))));
				}
				metadata.addChild(JUnitFactory.uniqueId(testIdentifier.getUniqueIdObject()));
				metadata.addChild(JUnitFactory.legacyReportingName(testIdentifier.getLegacyReportingName()));
				metadata.addChild(JUnitFactory.type(testIdentifier.getType()));
			});
			testIdentifier.getSource().ifPresent(
				source -> started.addChild(CoreFactory.sources(), sources -> addTestSource(source, sources)));
		});
	}

	private void addTestSource(TestSource source, Sources sources) {
		if (source instanceof CompositeTestSource) {
			((CompositeTestSource) source).getSources().forEach(it -> addTestSource(it, sources));
		}
		else if (source instanceof ClassSource) {
			ClassSource classSource = (ClassSource) source;
			sources.addChild(JavaFactory.classSource(classSource.getClassName()), //
				element -> classSource.getPosition().ifPresent(
					filePosition -> element.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
		}
		else if (source instanceof MethodSource) {
			MethodSource methodSource = (MethodSource) source;
			sources.addChild(JavaFactory.methodSource(methodSource.getClassName(), methodSource.getMethodName()),
				element -> {
					String methodParameterTypes = methodSource.getMethodParameterTypes();
					if (methodParameterTypes != null) {
						element.withMethodParameterTypes(methodParameterTypes);
					}
				});
		}
		else if (source instanceof ClasspathResourceSource) {
			ClasspathResourceSource classpathResourceSource = (ClasspathResourceSource) source;
			sources.addChild(JavaFactory.classpathResourceSource(classpathResourceSource.getClasspathResourceName()), //
				element -> classpathResourceSource.getPosition().ifPresent(
					filePosition -> element.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
		}
		else if (source instanceof PackageSource) {
			sources.addChild(JavaFactory.packageSource(((PackageSource) source).getPackageName()));
		}
		else if (source instanceof FileSource) {
			FileSource fileSource = (FileSource) source;
			sources.addChild(CoreFactory.fileSource(fileSource.getFile()), //
				element -> fileSource.getPosition().ifPresent(
					filePosition -> element.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
		}
		else if (source instanceof DirectorySource) {
			sources.addChild(CoreFactory.directorySource(((DirectorySource) source).getFile()));
		}
		else if (source instanceof UriSource) {
			sources.addChild(CoreFactory.uriSource(((UriSource) source).getUri()));
		}
	}

	@Override
	public void reportingEntryPublished(TestIdentifier testIdentifier, ReportEntry entry) {
		String id = inProgressIds.get(testIdentifier.getUniqueIdObject());
		eventsFileWriter.append(EventFactory.reported(id), //
			reported -> reported.addChild(CoreFactory.attachments(),
				attachments -> attachments.addChild(CoreFactory.data(), data -> {
					data.withTime(entry.getTimestamp());
					entry.getKeyValuePairs().forEach(data::addEntry);
				})));
	}

	@Override
	public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {
		String id = inProgressIds.remove(testIdentifier.getUniqueIdObject());
		eventsFileWriter.append(EventFactory.finished(id, Instant.now()), //
			finished -> finished.addChild(CoreFactory.result(convertStatus(testExecutionResult.getStatus())), //
				result -> testExecutionResult.getThrowable() //
						.ifPresent(throwable -> result.addChild(JavaFactory.throwable(throwable)))));
	}

	private Result.Status convertStatus(TestExecutionResult.Status status) {
		switch (status) {
			case FAILED:
				return Result.Status.FAILED;
			case SUCCESSFUL:
				return Result.Status.SUCCESSFUL;
			case ABORTED:
				return Result.Status.ABORTED;
		}
		throw new JUnitException("Unhandled status: " + status);
	}

}
