package org.junit.platform.reporting.open.xml;

import org.junit.platform.commons.JUnitException;
import org.junit.platform.commons.util.StringUtils;
import org.junit.platform.engine.TestExecutionResult;
import org.junit.platform.engine.TestSource;
import org.junit.platform.engine.UniqueId;
import org.junit.platform.engine.reporting.ReportEntry;
import org.junit.platform.engine.support.descriptor.ClassSource;
import org.junit.platform.engine.support.descriptor.ClasspathResourceSource;
import org.junit.platform.engine.support.descriptor.CompositeTestSource;
import org.junit.platform.engine.support.descriptor.DirectorySource;
import org.junit.platform.engine.support.descriptor.FileSource;
import org.junit.platform.engine.support.descriptor.MethodSource;
import org.junit.platform.engine.support.descriptor.PackageSource;
import org.junit.platform.engine.support.descriptor.UriSource;
import org.junit.platform.launcher.TestExecutionListener;
import org.junit.platform.launcher.TestIdentifier;
import org.junit.platform.launcher.TestPlan;
import org.opentest4j.reporting.events.api.EventReportFileWriter;
import org.opentest4j.reporting.events.api.Namespace;
import org.opentest4j.reporting.events.api.NamespaceRegistry;
import org.opentest4j.reporting.events.core.CoreFactory;
import org.opentest4j.reporting.events.core.Result;
import org.opentest4j.reporting.events.core.Sources;
import org.opentest4j.reporting.events.java.JavaFactory;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class OpenTestReportGeneratingListener implements TestExecutionListener {

    private final Path reportDir;

    private final AtomicInteger idCounter = new AtomicInteger();
    private final Map<UniqueId, String> inProgressIds = new ConcurrentHashMap<>();
    private EventReportFileWriter eventWriter;

    public OpenTestReportGeneratingListener() {
        this(lookupReportDirFromSystemProperties());
    }

    private static Path lookupReportDirFromSystemProperties() {
        String reportDir = System.getProperty("junit.platform.reports.dir");
        return reportDir != null ? Paths.get(reportDir) : null;
    }

    public OpenTestReportGeneratingListener(Path reportDir) {
        this.reportDir = reportDir;
    }

    @Override
    public void testPlanExecutionStarted(TestPlan testPlan) {
        if (reportDir != null) {
            try {
                Files.createDirectories(reportDir);
                Map<Namespace, String> additionalNamespaces = new HashMap<>();
                additionalNamespaces.put(JavaFactory.NAMESPACE, "java");
                additionalNamespaces.put(JUnitFactory.NAMESPACE, "junit");
                Path eventsXml = reportDir.resolve("junit-platform-events-" + System.currentTimeMillis() + ".xml");
                eventWriter = new EventReportFileWriter(eventsXml, NamespaceRegistry.of(additionalNamespaces));
                reportInfrastructure();
            } catch (Exception e) {
                throw new RuntimeException("Failed to close XML events file", e);
            }
        }
    }

    private void reportInfrastructure() {
        eventWriter.append(CoreFactory.infrastructure(), infrastructure -> {
            try {
                String hostName = InetAddress.getLocalHost().getHostName();
                infrastructure.addChild(CoreFactory.hostName(hostName));
            } catch (UnknownHostException ignored) {
            }
            infrastructure.addChild(CoreFactory.userName(System.getProperty("user.name")));
            infrastructure.addChild(CoreFactory.operatingSystem(System.getProperty("os.name")));
            infrastructure.addChild(CoreFactory.cpuCores(Runtime.getRuntime().availableProcessors()));
            infrastructure.addChild(JavaFactory.javaVersion(System.getProperty("java.version")));
            infrastructure.addChild(JavaFactory.fileEncoding(System.getProperty("file.encoding")));
            infrastructure.addChild(JavaFactory.heapSize(), heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));
        });
    }

    @Override
    public void testPlanExecutionFinished(TestPlan testPlan) {
        if (eventWriter != null) {
            try {
                eventWriter.close();
            } catch (IOException e) {
                throw new UncheckedIOException("Failed to close XML events file", e);
            } finally {
                eventWriter = null;
            }
        }
    }

    @Override
    public void executionSkipped(TestIdentifier testIdentifier, String reason) {
        String id = String.valueOf(idCounter.incrementAndGet());
        reportStarted(testIdentifier, id);
        eventWriter.append(CoreFactory.finished(id, Instant.now()), finished -> {
            finished.addChild(CoreFactory.result(Result.Status.SKIPPED), result -> {
                if (StringUtils.isNotBlank(reason)) {
                    result.addChild(CoreFactory.reason(reason));
                }
            });
        });
    }

    @Override
    public void executionStarted(TestIdentifier testIdentifier) {
        String id = String.valueOf(idCounter.incrementAndGet());
        inProgressIds.put(testIdentifier.getUniqueIdObject(), id);
        reportStarted(testIdentifier, id);
    }

    private void reportStarted(TestIdentifier testIdentifier, String id) {
        eventWriter.append(CoreFactory.started(id, Instant.now(), testIdentifier.getDisplayName()), started -> {
            testIdentifier.getParentIdObject().ifPresent(parentId -> started.withParentId(inProgressIds.get(parentId)));
            started.addChild(CoreFactory.metadata(), metadata -> {
                if (!testIdentifier.getTags().isEmpty()) {
                    metadata.addChild(CoreFactory.tags(), tags -> //
                            testIdentifier.getTags().forEach(tag -> tags.addChild(CoreFactory.tag(tag.getName()))));
                }
                metadata.addChild(JUnitFactory.uniqueId(testIdentifier.getUniqueIdObject()));
                metadata.addChild(JUnitFactory.legacyReportingName(testIdentifier.getLegacyReportingName()));
                metadata.addChild(JUnitFactory.type(testIdentifier.getType()));
            });
            testIdentifier.getSource().ifPresent(source -> started.addChild(CoreFactory.sources(), sources -> addTestSource(source, sources)));
        });
    }

    private void addTestSource(TestSource source, Sources sources) {
        if (source instanceof CompositeTestSource) {
            ((CompositeTestSource) source).getSources().forEach(it -> addTestSource(it, sources));
        } else if (source instanceof ClassSource) {
            ClassSource classSource = (ClassSource) source;
            sources.addChild(JavaFactory.classSource(classSource.getClassName()), classSourceElement -> //
                    classSource.getPosition()
                            .ifPresent(filePosition -> classSourceElement.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
        } else if (source instanceof MethodSource) {
            MethodSource methodSource = (MethodSource) source;
            sources.addChild(JavaFactory.methodSource(methodSource.getClassName(), methodSource.getMethodName()), methodSourceElement -> {
                String methodParameterTypes = methodSource.getMethodParameterTypes();
                if (methodParameterTypes != null) {
                    methodSourceElement.withMethodParameterTypes(methodParameterTypes);
                }
            });
        } else if (source instanceof ClasspathResourceSource) {
            ClasspathResourceSource classpathResourceSource = (ClasspathResourceSource) source;
            sources.addChild(JavaFactory.classpathResourceSource(classpathResourceSource.getClasspathResourceName()), classpathResourceSourceElement -> //
                    classpathResourceSource.getPosition()
                            .ifPresent(filePosition -> classpathResourceSourceElement.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
        } else if (source instanceof PackageSource) {
            sources.addChild(JavaFactory.packageSource(((PackageSource) source).getPackageName()));
        } else if (source instanceof FileSource) {
            FileSource fileSource = (FileSource) source;
            sources.addChild(CoreFactory.fileSource(fileSource.getFile()), fileSourceElement -> {
                fileSource.getPosition().ifPresent(filePosition -> fileSourceElement.addFilePosition(filePosition.getLine(), filePosition.getColumn()));
            });
        } else if (source instanceof DirectorySource) {
            sources.addChild(CoreFactory.directorySource(((DirectorySource) source).getFile()));
        } else if (source instanceof UriSource) {
            sources.addChild(CoreFactory.uriSource(((UriSource) source).getUri()));
        }
    }

    @Override
    public void reportingEntryPublished(TestIdentifier testIdentifier, ReportEntry entry) {
        String id = inProgressIds.get(testIdentifier.getUniqueIdObject());
        eventWriter.append(CoreFactory.reported(id), reported -> {
            reported.addChild(CoreFactory.attachments(), attachments -> attachments.addChild(CoreFactory.data(), data -> {
                data.withTime(entry.getTimestamp());
                entry.getKeyValuePairs().forEach(data::addEntry);
            }));
        });
    }

    @Override
    public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {
        String id = inProgressIds.remove(testIdentifier.getUniqueIdObject());
        eventWriter.append(CoreFactory.finished(id, Instant.now()), finished -> {
            finished.addChild(CoreFactory.result(convertStatus(testExecutionResult.getStatus())), result -> {
                testExecutionResult.getThrowable().ifPresent(throwable -> {
                    result.addChild(JavaFactory.throwable(throwable));
                });
            });
        });
    }

    private Result.Status convertStatus(TestExecutionResult.Status status) {
        switch (status) {
            case FAILED:
                return Result.Status.FAILED;
            case SUCCESSFUL:
                return Result.Status.SUCCESSFUL;
            case ABORTED:
                return Result.Status.ABORTED;
        }
        throw new JUnitException("Unhandled status: " + status);
    }

}
